// Package log implements a simple logging package with json format
// which is convenient for searching in logging utilities like Splunk.
// It is based on the "log" package in stdlib and the definitions
// in the "github.com/Sirupsen/logrus" package.
// It defines a type, Logger, with methods for formatting output.
//
// The log method
//
//     logj.Info("start", "key1", "textValue", "key2", 123)
//
// may create the following log in JSON:
//
// {"name":"start","time":"2016-03-18T01:23:23Z","file":"d.go","line":23,"method":"package_name.method","data":{"key1":"textValue","key2":123}}
//
// It also has a predefined 'standard' Logger accessible through helper
// functions Debug[|m], Info[|m], Warn[|m], Error[|m], Panic[|m],
// Fatal[|m], and Panic[|m], which are easier to use than creating a
// Logger manually.That logger writes to standard error and prints
// data/time/file/line/method.
// The Fatal functions call os.Exit(1) after writing the event name.
// The Panic functions call panic after writing the event name.

package logj

import (
	"encoding/json"
	"fmt"
	"io"
	"os"
	"runtime"
	"sync"
	"time"
)

// These flags define which field to add to each log entry generated by the Logger.
const (
	// Bits or'ed together to control what's printed.
	Ldate         = 1 << iota                                            // the date in the local time zone: {"time":"2016-03-18"}
	Ltime                                                                // the time in the local time zone: {"time":"2016-03-18T01:23:23Z"}
	Lmicroseconds                                                        // microsecond resolution: {"time":"2016-03-18T01:23:23.123Z"}.  assumes Ltime.
	Llongfile                                                            // full file name and line number: {"file":"/a/b/c/d.go","line":23}
	Lshortfile                                                           // final file name element and line number: {"file":"d.go","line":23}. Overrides Llongfile
	Lmetohd                                                              // method calling the log: {"method":"package_name.method"}
	LUTC                                                                 // if Ldate or Ltime is set, use UTC rather than the local time zone
	LstdFlags     = Ldate | Ltime | Lmicroseconds | Lshortfile | Lmetohd // initial values for the standard logger
	LdefaultFlags = LstdFlags | LUTC
)

// Level type
type Level int

const callDepth int = 2

type Logger struct {
	mu    sync.Mutex // ensures atomic writes; protects the following fields
	buf   []byte     // for buffering text to write.
	flag  int        // flags to control what to output.
	level Level      // log level.
	out   io.Writer  // destination for output
}

func New(out io.Writer, flag int, level Level) *Logger {
	return &Logger{out: out, flag: flag, level: level}
}

func NewWithOutput(out io.Writer) *Logger {
	return New(out, LdefaultFlags, LevelInfo)
}

var std = New(os.Stderr, LstdFlags, LevelInfo)

// These are the different logging levels. You can set the logging level to log
const (
	// PanicLevel level, highest level of severity. Logs and then calls panic with the
	// message passed to Debug, Info, ...
	LevelPanic Level = iota
	// FatalLevel level. Logs and then calls `os.Exit(1)`. It will exit even if the
	// logging level is set to Panic.
	LevelFatal
	// ErrorLevel level. Logs. Used for errors that should definitely be noted.
	// Commonly used for hooks to send errors to an error tracking service.
	LevelError
	// WarnLevel level. Non-critical entries that deserve eyes.
	LevelWarn
	// InfoLevel level. General operational entries about what's going on inside the
	// application.
	LevelInfo
	// DebugLevel level. Usually only enabled when debugging. Very verbose logging.
	LevelDebug
)

// Convert the Level to a string. E.g. PanicLevel becomes "panic".
func (level Level) String() string {
	switch level {
	case LevelDebug:
		return "debug"
	case LevelInfo:
		return "info"
	case LevelWarn:
		return "warn"
	case LevelError:
		return "error"
	case LevelFatal:
		return "fatal"
	case LevelPanic:
		return "panic"
	}

	return "unknown"
}

// ParseLevel takes a string level and returns the Logrus log level constant.
func ParseLevel(level string) (Level, error) {
	switch level {
	case "panic":
		return LevelPanic, nil
	case "fatal":
		return LevelFatal, nil
	case "error":
		return LevelError, nil
	case "warn", "warning":
		return LevelWarn, nil
	case "info":
		return LevelInfo, nil
	case "debug":
		return LevelDebug, nil
	}

	var l Level
	return l, fmt.Errorf("not a valid log Level: %q", level)
}

func getDataMap(dataEntries []interface{}) map[string]interface{} {
	dataMap := make(map[string]interface{})

	count := len(dataEntries)

	var i int
	for i = 0; i < count-1; i += 2 {
		var v interface{}
		switch dataEntries[i+1].(type) {
		case error:
			v = dataEntries[i+1].(error).Error()
		default:
			v = dataEntries[i+1]
		}
		//switch (dataEntries[i+1].(type))
		switch dataEntries[i].(type) {
		case string:
			dataMap[dataEntries[i].(string)] = v
		default:
			dataMap[fmt.Sprintf("%v", dataEntries[i])] = v
			fmt.Printf("Error: not a string key: %v.", dataEntries[i])
		}
	}
	if i < count {
		fmt.Printf("Error: incomplete key value pair %v.", dataEntries[i])
	}

	return dataMap
}

func (l *Logger) Debug(event string, dataEntry ...interface{}) {
	if l.level >= LevelDebug {
		dataMap := getDataMap(dataEntry)
		l.Output(callDepth, LevelDebug, event, dataMap)
	}
}

func (l *Logger) Debugm(event string, dataMap map[string]interface{}) {
	if l.level >= LevelDebug {
		l.Output(callDepth, LevelDebug, event, dataMap)
	}
}

func (l *Logger) Info(event string, dataEntry ...interface{}) {
	if l.level >= LevelInfo {
		dataMap := getDataMap(dataEntry)
		l.Output(callDepth, LevelInfo, event, dataMap)
	}
}

func (l *Logger) Infom(event string, dataMap map[string]interface{}) {
	if l.level >= LevelInfo {
		l.Output(callDepth, LevelInfo, event, dataMap)
	}
}

func (l *Logger) Warn(event string, dataEntry ...interface{}) {
	if l.level >= LevelWarn {
		dataMap := getDataMap(dataEntry)
		l.Output(callDepth, LevelWarn, event, dataMap)
	}
}

func (l *Logger) Warnm(event string, dataMap map[string]interface{}) {
	if l.level >= LevelWarn {
		l.Output(callDepth, LevelWarn, event, dataMap)
	}
}

func (l *Logger) Error(event string, dataEntry ...interface{}) {
	if l.level >= LevelError {
		dataMap := getDataMap(dataEntry)
		l.Output(callDepth, LevelError, event, dataMap)
	}
}

func (l *Logger) Errorm(event string, dataMap map[string]interface{}) {
	if l.level >= LevelError {
		l.Output(callDepth, LevelError, event, dataMap)
	}
}

func (l *Logger) Panic(event string, dataEntry ...interface{}) {
	if l.level >= LevelPanic {
		dataMap := getDataMap(dataEntry)
		l.Output(callDepth, LevelPanic, event, dataMap)
	}
	panic(event)
}

func (l *Logger) Panicm(event string, dataMap map[string]interface{}) {
	if l.level >= LevelPanic {
		l.Output(callDepth, LevelPanic, event, dataMap)
	}
	panic(event)
}

func (l *Logger) Fatal(event string, dataEntry ...interface{}) {
	if l.level >= LevelFatal {
		dataMap := getDataMap(dataEntry)
		l.Output(callDepth, LevelFatal, event, dataMap)
	}
	os.Exit(1)
}

func (l *Logger) Fatalm(event string, dataMap map[string]interface{}) {
	if l.level >= LevelFatal {
		l.Output(callDepth, LevelFatal, event, dataMap)
	}
	os.Exit(1)
}

// Flags returns the output flags for the logger.
func (l *Logger) Flags() int {
	l.mu.Lock()
	defer l.mu.Unlock()
	return l.flag
}

// SetFlags sets the output flags for the logger.
func (l *Logger) SetFlags(flag int) {
	l.mu.Lock()
	defer l.mu.Unlock()
	l.flag = flag
}

// SetOutput sets the output destination for the standard logger.
func (l *Logger) SetOutput(w io.Writer) {
	l.mu.Lock()
	defer l.mu.Unlock()
	l.out = w
}

func Debug(event string, dataEntry ...interface{}) {
	if std.level >= LevelDebug {
		dataMap := getDataMap(dataEntry)
		std.Output(callDepth, LevelDebug, event, dataMap)
	}
}

func Debugm(event string, dataMap map[string]interface{}) {
	if std.level >= LevelDebug {
		std.Output(callDepth, LevelDebug, event, dataMap)
	}
}

func Info(event string, dataEntry ...interface{}) {
	if std.level >= LevelInfo {
		dataMap := getDataMap(dataEntry)
		std.Output(callDepth, LevelInfo, event, dataMap)
	}
}

func Infom(event string, dataMap map[string]interface{}) {
	if std.level >= LevelInfo {
		std.Output(callDepth, LevelInfo, event, dataMap)
	}
}

func Warn(event string, dataEntry ...interface{}) {
	if std.level >= LevelWarn {
		dataMap := getDataMap(dataEntry)
		std.Output(callDepth, LevelWarn, event, dataMap)
	}
}

func Warnm(event string, dataMap map[string]interface{}) {
	if std.level >= LevelWarn {
		std.Output(callDepth, LevelWarn, event, dataMap)
	}
}

func Error(event string, dataEntry ...interface{}) {
	if std.level >= LevelError {
		dataMap := getDataMap(dataEntry)
		std.Output(callDepth, LevelError, event, dataMap)
	}
}

func Errorm(event string, dataMap map[string]interface{}) {
	if std.level >= LevelError {
		std.Output(callDepth, LevelError, event, dataMap)
	}
}

func Panic(event string, dataEntry ...interface{}) {
	if std.level >= LevelPanic {
		dataMap := getDataMap(dataEntry)
		std.Output(callDepth, LevelPanic, event, dataMap)
	}
	panic(event)
}

func Panicm(event string, dataMap map[string]interface{}) {
	if std.level >= LevelPanic {
		std.Output(callDepth, LevelPanic, event, dataMap)
	}
	panic(event)
}

func Fatal(event string, dataEntry ...interface{}) {
	if std.level >= LevelFatal {
		dataMap := getDataMap(dataEntry)
		std.Output(callDepth, LevelFatal, event, dataMap)
	}
	os.Exit(1)
}

func Fatalm(event string, dataMap map[string]interface{}) {
	if std.level >= LevelFatal {
		std.Output(callDepth, LevelFatal, event, dataMap)
	}
	os.Exit(1)
}

// SetOutput sets the output destination for the standard logger.
func SetOutput(w io.Writer) {
	std.mu.Lock()
	defer std.mu.Unlock()
	std.out = w
}

// Flags returns the output flags for the standard logger.
func Flags() int {
	return std.Flags()
}

// SetFlags sets the output flags for the standard logger.
func SetFlags(flag int) {
	std.SetFlags(flag)
}

// Cheap integer to fixed-width decimal ASCII.  Give a negative width to avoid zero-padding.
func itoa(buf *[]byte, i int, wid int) {
	// Assemble decimal in reverse order.
	var b [20]byte
	bp := len(b) - 1
	for i >= 10 || wid > 1 {
		wid--
		q := i / 10
		b[bp] = byte('0' + i - q*10)
		bp--
		i = q
	}
	// i < 10
	b[bp] = byte('0' + i)
	*buf = append(*buf, b[bp:]...)
}

func formatHeaders(buf *[]byte, flag int, level Level, event string, t time.Time, file string, line int, method string) {
	*buf = append(*buf, "{\"name\":\""...)
	*buf = append(*buf, event...)
	*buf = append(*buf, "\",\"level\":\""...)
	*buf = append(*buf, level.String()...)
	*buf = append(*buf, "\""...)

	if flag&(Ldate|Ltime|Lmicroseconds) != 0 {
		*buf = append(*buf, ",\"time\":\""...)
		if flag&Ldate != 0 {
			year, month, day := t.Date()
			itoa(buf, year, 4)
			*buf = append(*buf, '-')
			itoa(buf, int(month), 2)
			*buf = append(*buf, '-')
			itoa(buf, day, 2)
		}
		if flag&(Ltime|Lmicroseconds) != 0 {
			*buf = append(*buf, 'T')
			hour, min, sec := t.Clock()
			itoa(buf, hour, 2)
			*buf = append(*buf, ':')
			itoa(buf, min, 2)
			*buf = append(*buf, ':')
			itoa(buf, sec, 2)
			if flag&Lmicroseconds != 0 {
				*buf = append(*buf, '.')
				itoa(buf, t.Nanosecond()/1e6, 3)
			}
			*buf = append(*buf, 'Z')
		}
		*buf = append(*buf, '"')
	}

	if flag&(Lshortfile|Llongfile) != 0 {
		*buf = append(*buf, ",\"file\":\""...)
		*buf = append(*buf, file...)
		*buf = append(*buf, "\",\"line\":"...)
		itoa(buf, line, -1)
	}

	if flag&Lmetohd != 0 {
		*buf = append(*buf, ",\"method\":\""...)
		*buf = append(*buf, method...)
		*buf = append(*buf, '"')
	}
}

func formatData(dataMap map[string]interface{}) []byte {
	buf, err := json.Marshal(dataMap)
	if err != nil {
		return []byte("{\"formatDataError\":true}")
	}

	return buf
}

func (l *Logger) Output(callDepth int, level Level, event string, dataMap map[string]interface{}) error {
	now := time.Now()

	var file string
	var line int
	var method string

	flag := l.flag

	if flag&LUTC != 0 {
		now = now.UTC()
	}

	if flag&(Lshortfile|Llongfile|Lmetohd) != 0 {
		var ok bool
		var pc uintptr
		pc, file, line, ok = runtime.Caller(callDepth)
		if !ok {
			file = "???"
			line = 0
		}
		if flag&Lshortfile != 0 {
			short := file
			for i := len(file) - 1; i > 0; i-- {
				if file[i] == '/' {
					short = file[i+1:]
					break
				}
			}
			file = short
		}
		if flag&Lmetohd != 0 {
			method = runtime.FuncForPC(pc).Name()
		}
	}

	dataBuf := formatData(dataMap)

	l.mu.Lock()
	defer l.mu.Unlock()

	l.buf = l.buf[:0]

	formatHeaders(&l.buf, l.flag, level, event, now, file, line, method)
	l.buf = append(l.buf, ",\"data\":"...)
	l.buf = append(l.buf, dataBuf...)
	l.buf = append(l.buf, "}\n"...)

	_, err := l.out.Write(l.buf)
	return err
}
